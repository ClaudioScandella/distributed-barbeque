/*
 * Copyright (C) 2012  Politecnico di Milano
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef BBQUE_YAMS_SCHEDPOL_H_
#define BBQUE_YAMS_SCHEDPOL_H_

#include <cstdint>

#include "bbque/configuration_manager.h"
#include "bbque/scheduler_manager.h"
#include "bbque/command_manager.h"
#include "bbque/plugins/plugin.h"

#include "contrib/sched_contrib_manager.h"

#undef  MODULE_NAMESPACE
#undef  MODULE_CONFIG
#define SCHEDULER_POLICY_NAME "yams"
#define MODULE_NAMESPACE SCHEDULER_POLICY_NAMESPACE "." SCHEDULER_POLICY_NAME
#define MODULE_CONFIG SCHEDULER_POLICY_CONFIG "." SCHEDULER_POLICY_NAME

/** Metrics (class SAMPLE) declaration */
#define YAMS_SAMPLE_METRIC(NAME, DESC)\
 {SCHEDULER_MANAGER_NAMESPACE ".yams." NAME, DESC, \
	 MetricsCollector::SAMPLE, 0, NULL, 0}
/** Reset the timer used to evaluate metrics */
#define YAMS_RESET_TIMING(TIMER) \
	TIMER.start();
/** Acquire a new completion time sample */
#define YAMS_GET_TIMING(METRICS, INDEX, TIMER) \
	mc.AddSample(METRICS[INDEX].mh, TIMER.getElapsedTimeMs());

/* Get a new sample for the metrics */
#define YAMS_GET_SAMPLE(METRICS, INDEX, VALUE) \
	mc.AddSample(METRICS[INDEX].mh, VALUE);

/* Number of scheduling contributions used for the scheduling metrics
 * computation */

#define YAMS_AWM_SC_COUNT 3
#ifndef CONFIG_BBQUE_SP_COWS_BINDING
	#define YAMS_BD_SC_COUNT  2
#else
	#define YAMS_BD_SC_COUNT  1
#endif
#define YAMS_SC_COUNT (YAMS_AWM_SC_COUNT + YAMS_BD_SC_COUNT)

#ifdef CONFIG_BBQUE_SP_COWS_BINDING
	#define COWS_BOUND_METRICS  1
	#define COWS_UNITS_METRICS  3
	#define COWS_ADDITIONAL_METRICS 1
	#define COWS_RECIPE_METRICS (COWS_BOUND_METRICS + COWS_UNITS_METRICS)
	#define COWS_NORMAL_VALUES  (COWS_RECIPE_METRICS + COWS_ADDITIONAL_METRICS)
	#define COWS_AGGREGATION_WEIGHTS 3
	#define COWS_TOTAL_WEIGHT_SUM 10.0
	#include <boost/accumulators/accumulators.hpp>
	#include <boost/accumulators/statistics/stats.hpp>
	#include <boost/accumulators/statistics/count.hpp>
	#include <boost/accumulators/statistics/mean.hpp>
	#include <boost/accumulators/statistics/variance.hpp>
	using namespace boost::accumulators;
#endif


using bbque::res::RViewToken_t;
using bbque::utils::Timer;
using bbque::utils::MetricsCollector;

// These are the parameters received by the PluginManager on create calls
struct PF_ObjectParams;

namespace bbque { namespace plugins {


// Forward declaration
class LoggerIF;

/**
 * @class YamsSchedPol
 *
 * The yams resource scheduler heuristic registered as a dynamic C++
 * plugin.
 */
class YamsSchedPol: public SchedulerPolicyIF, CommandHandler {

public:

	// :::::::::::::::::::::: Static plugin interface :::::::::::::::::::::::::

	/**
	 * @brief Create the plugin
	 */
	static void * Create(PF_ObjectParams *);

	/**
	 * @brief Destroy the plugin
	 */
	static int32_t Destroy(void *);


	// :::::::::::::::::: Scheduler policy module interface :::::::::::::::::::

	/**
	 * @brief Destructor
	 */
	virtual ~YamsSchedPol();

	/**
	 * @see SchedulerPolicyIF
	 */
	char const * Name();

	/**
	 * @see SchedulerPolicyIF
	 */
	ExitCode_t Schedule(System & sys_if, RViewToken_t & rav);

	/**
	 * @see CommandHandler
	 */
	int CommandsCb(int argc, char *argv[]);


private:

	/**
	 * @brief Specific internal exit code for YaMS
	 */
	enum ExitCode_t {
		YAMS_SUCCESS,
		YAMS_FULL_BINDING,
		YAMS_IGNORE,
		YAMS_ERROR,
		YAMS_ERROR_VIEW,
		YAMS_ERROR_BINDING,
		YAMS_ERROR_COWS
	};

	/**
	 * @brief Collection of statistical metrics generated by this module
	 */
	enum SchedPolMetrics_t {
		// :::: Timing metrics
		YAMS_ORDERING_TIME,
		YAMS_SELECTING_TIME,
		YAMS_METRICS_COMP_TIME,
		YAMS_METRICS_AWMVALUE,
		YAMS_METRICS_COUNT
	};

	/**
	 * @brief Collection of statistical metrics for contribute computations
	 */
	enum MCTimeMetrics_t {
		YAMS_VALUE_COMP_TIME,
		YAMS_RECONFIG_COMP_TIME,
		YAMS_CONGESTION_COMP_TIME,
		YAMS_FAIRNESS_COMP_TIME
		// ...:: ADD_MCT ::...
	};

	/**
	 * @brief Metrics used by COWS to chose the preferred bindings
	 */

#ifdef CONFIG_BBQUE_SP_COWS_BINDING
	enum CowsMetrics_t {
		COWS_STALLS,
		COWS_IRET,
		COWS_FLOPS,
		COWS_LLCM,
		COWS_MIGRA
	};

	/**
	 * @brief Weights used by COWS to aggregate the metrics
	 */
	enum CowsAggregationWeights_t {
		COWS_BOUND_WEIGHT,
		COWS_UNITS_WEIGHT,
		COWS_MIGRA_WEIGHT
	};
#endif

	/** Shared pointer to a scheduling entity */
	typedef std::shared_ptr<SchedEntity_t> SchedEntityPtr_t;

	/** List of scheduling entities */
	typedef std::list<SchedEntityPtr_t> SchedEntityList_t;


	/** Configuration manager instance */
	ConfigurationManager & cm;

	/** Resource accounter instance */
	ResourceAccounter & ra;

	/** Metric collector instance */
	MetricsCollector & mc;

	/** Command manager instance */
	CommandManager &cmm;

	/** System logger instance */
	LoggerIF *logger = NULL;

	/** System view instance */
	System * sv = NULL;

	/** Token for accessing a resources view */
	RViewToken_t vtok = 0;

	/** A counter used for getting always a new clean resources view */
	uint32_t vtok_count = 0;

	/** List of entities to schedule */
	SchedEntityList_t entities;


	/** Set of scheduling contributions type used for the metrics */
	static SchedContribManager::Type_t sc_types[YAMS_SC_COUNT];
	static SchedContribManager::Type_t sc_gpu[];

#ifdef CONFIG_BBQUE_SP_COWS_BINDING

	/**Cows metrics*/
	struct cows_system_info{
		/**Applications scheduled on each BD and on the whole system */
		std::vector<int> bd_load;
		int bd_total_load;
		/*Metrics of the SchedEnt under analysis */
		std::vector<float> perf_data;
		std::multimap<float,int> ordered_bds;
		/*statistic info used to normalize the metrics */
		std::vector<float> norm_stats;
		/* Metrics container per BD */
		std::vector<double> bound_mix;
		std::vector<float> stalls_metrics;
		std::vector<float> iret_metrics;
		std::vector<float> flops_metrics;
		std::vector<float> migr_metrics;
		/* Weights used to compute metrics */
		std::vector<float> m_weights;

	} cows_info;

	typedef accumulator_set<float, stats<tag::sum, tag::variance>> mv_metrics_t;
	typedef accumulator_set<float, stats<tag::mean>> syswide_metrics_t;

	struct cows_binding_info{
		mv_metrics_t llcm_info;
		mv_metrics_t stalls_info;
		mv_metrics_t iret_info;
		mv_metrics_t flops_info;
	};

	/** Char strings of the metrics in the recipe */
	static const char * cows_metrics_str[];

	std::vector<cows_binding_info> binding_domains;
	/** A set needed to simulate system changes */
	std::vector<cows_binding_info> binding_speculative;
	/** A set needed to reset the original one */
	std::vector<cows_binding_info> binding_empty;
	/** Accumulator for sys-wide sums information */
	std::vector<syswide_metrics_t> syswide_sums;
	/** A set needed to reset the original one */
	std::vector<syswide_metrics_t> syswide_empty;

	/** Info about CPU bindings to evaluate */
	BindingInfo_t * cpu_bindings;
#endif

	/** Manager for the scheduling contributions set */
	typedef std::pair<Resource::Type_t, SchedContribManager *> SchedContribPair_t;
	std::map<Resource::Type_t, SchedContribManager *> scms;

	/** Collect information on binding domains */
	typedef std::pair<Resource::Type_t, BindingInfo_t *> BindingPair_t;
	std::map<Resource::Type_t, BindingInfo_t *>  bindings;


	/** Mutex */
	std::mutex sched_mtx;


	/** The High-Resolution timer used for profiling */
	Timer yams_tmr;

	/** Statistical metrics of the scheduling policy */
	static MetricsCollector::MetricsCollection_t
		coll_metrics[YAMS_METRICS_COUNT];

	/** Statistical metrics for single contributes */
	static MetricsCollector::MetricsCollection_t
		coll_mct_metrics[YAMS_SC_COUNT];


	/**
	 * @brief The plugins constructor
	 *
	 * Plugins objects could be build only by using the "create" method.
	 * Usually the PluginManager acts as object
	 */
	YamsSchedPol();

	/**
	 * @brief Load the resource binding configuration
	 */
	YamsSchedPol::ExitCode_t LoadBindingConfig();

	/**
	 * @brief Clear information on scheduling entities and bindings
	 */
	void Clear();

	/**
	 * @brief Perform initialization operation
	 *
	 * In particular the method gets a token for accessing a clean resource
	 * state view, and retrieve the number of clusters available on the
	 * platform.
	 *
	 * @return YAMS_ERR_VIEW if a resource state view cannot be retrieved.
	 * YAMS_ERR_CLUSTER if no clusters have been found on the platform.
	 * YAMS_SUCCESS if initialization has been successfyully completed
	 */
	YamsSchedPol::ExitCode_t Init();

	/**
	 * @brief Initialize a new resource state view
	 */
	YamsSchedPol::ExitCode_t InitResourceStateView();

	/**
	 * @brief Initialize the base information needed for the resource binding
	 */
	YamsSchedPol::ExitCode_t InitBindingInfo();

	/**
	 * @brief Initalize scheduling contributions managers (one per binding
	 * domain)
	 */
	YamsSchedPol::ExitCode_t InitSchedContribManagers();

	/**
	 * @brief Schedule applications from a priority queue
	 *
	 * @param prio The priority applications queue to schedule
	 */
	void SchedulePrioQueue(AppPrio_t prio);

	/**
	 * @brief Order the scheduling entities per metrics value
	 *
	 * For each application create a scheduling entity made by the tern
	 * {Application, WorkingMode, Cluster ID} and place it into a list
	 * which is sorted in descending order of metrics value
	 *
	 * @param prio The priority queue to schedule
	 *
	 * @return the number of EXCs in this priority queue which have a
	 * NAP value asserted
	 */
	uint8_t OrderSchedEntities(AppPrio_t prio);

	/**
	 * @brief Metrics of all the AWMs of an Application
	 *
	 * @param papp Shared pointer to the Application/EXC to schedule
	 */
	void InsertWorkingModes(AppCPtr_t const & papp);

	/**
	 * @brief Evaluate an AWM
	 *
	 * @param pschd The scheduling entity to evaluate
	 */
	void EvalWorkingMode(SchedEntityPtr_t pschd);

	/**
	 * @brief Compute the metrics of the given scheduling entity
	 *
	 * This puts together all the contributes for the metrics computation
	 *
	 * @param pschd The scheduling entity to evaluate
	 */
	void GetSchedContribValue(SchedEntityPtr_t pschd,
			ResourceIdentifier::Type_t bd_type,
			SchedContribManager::Type_t sc_type,
			float & sc_value);

	/**
	 * @brief Run-time reconfiguration of the scheduling contributions weights
	 *
	 * @param num_weights The size of the vector containing the new weights
	 * @param set_weights The vector containing the new weight values
	 */
	void ReconfigSchedContribWeights(
			uint8_t num_weights,
			char * set_weights[YAMS_SC_COUNT]);

	/**
	 * @brief Evaluate the scheduling bindings for each domain
	 *
	 * @param dom_it  Map iterator pointing the binding domain
	 * @param dom_end End of the binding domain map iterator
	 * @param last_it Iterator pointing the last binding domain evaluated
	 * @param pschd_parent SchedEntity_t to fill (in case)
	 */
	void EvalDomains(
			std::map<Resource::Type_t, SchedEntityPtr_t>::iterator dom_it,
			std::map<Resource::Type_t, SchedEntityPtr_t>::iterator dom_end,
			std::map<Resource::Type_t, SchedEntityPtr_t>::iterator & last_it);

	/**
	 * @brief Recursive evaluation of bindings
	 *
	 * @param dom_it  Map iterator pointing the binding domain
	 * @param dom_end End of the binding domain map iterator
	 * @param next_it Iterator tracking the next binding domain to evaluate
	 * @param pschd_parent SchedEntity_t to fill (in case)
	 *
	 * @return YAMS_IGNORE if a resource binding cannot be performed,
	 * YAMS_SUCCESS otherwise
	 */
	ExitCode_t EvalBindings(
			std::map<Resource::Type_t, SchedEntityPtr_t>::iterator dom_it,
			std::map<Resource::Type_t, SchedEntityPtr_t>::iterator dom_end,
			std::map<Resource::Type_t, SchedEntityPtr_t>::iterator & next_it,
			SchedEntityPtr_t pschd_parent);

	/**
	 * @brief Evaluate an AWM in a specific binding domain
	 *
	 * @param pschd  Scheduling entitity to evaluate
	 * @param b_refn Reference number of a previously bound resource set
	 * @param value  The value of the scheduling contributions aggregation
	 */
	ExitCode_t GetBoundContrib(SchedEntityPtr_t pschd_bd, size_t b_refn, float & value);

	/**
	 * @brief Bind the resources of the AWM into the given binding domain
	 *
	 * @param pschd The scheduling entity to evaluate
	 *
	 * @return YAMS_SUCCESS for success, YAMS_ERROR if an unexpected error has
	 * been encountered
	 */
	ExitCode_t BindResources(SchedEntityPtr_t pschd, size_t b_refn);

#ifdef CONFIG_BBQUE_SP_COWS_BINDING
	/**
	 * @brief COWS: Setup initial information required
	 */
	void CowsSetup();

	/**
	 * @brief COWS: Evaluate a Binding
	 *
	 * @param pschd The scheduling entity to evaluate
	 */
	void CowsBinding(SchedEntityPtr_t pschd);

	/**
	 * @brief COWS: reset resource counters
	 *
	 */
	void CowsClear();

	/**
	 * @brief COWS: Initialize with values extracted from recipe
	 */
	ExitCode_t CowsInit(SchedEntityPtr_t pschd);

	/**
	 * @brief COWS: compute the boundness variance variation for all BDs
	 *
	 * @param psch The scheduling entity to use
	 */
	void CowsBoundMix(SchedEntityPtr_t pschd);

	/**
	 * @brief COWS: compute stalls, retired, flops var delta for the system
	 */
	void CowsUnitsBalance();

	/**
	 * @brief COWS: aggregate results
	 */
	void CowsAggregateResults();

	/**
	 * @brief COWS: Update Means
	 *
	 * @param pschd The scheduling entity to use to update
	 */
	void CowsUpdateMeans(int logic_index);
	void CowsUpdateMeans(SchedEntityPtr_t pschd);

	/**
	 * @brief Command handler for COWS specific commands
	 */
	int CowsCommandsHandler(int argc, char * argv[]);
#endif

	/**
	 * @brief Require the scheduling of the entities
	 *
	 * For each application pick the next working mode to schedule.
	 * If a number of applications with NAP asserted has been specified,
	 * than this method return (with a true) as soon as all the "NAPped"
	 * applications have been already scheduled.
	 *
	 * @param naps_count the number of EXC, among those to be selected,
	 * which have a NAP value asserted.
	 * @return true if the schedule for these entities has not been
	 * competed
	 */
	bool SelectSchedEntities(uint8_t naps_count);

	/**
	 * @brief Check if an application/EXC must be skipped
	 *
	 * Whenever we are in the ordering or the selecting step, the
	 * application/EXC must be skipped if some conditions are verified
	 *
	 * @param papp Shared pointer to the Application/EXC to schedule
	 * @return true if the Application/EXC must be skipped, false otherwise
	 */
	inline bool CheckSkipConditions(AppCPtr_t const & papp) {
		// Skip if the application has been rescheduled yet (with success) or
		// disabled in the meanwhile
		if (!papp->Active() && !papp->Blocking()) {
			logger->Debug("Skipping [%s] State = [%s, %s]",
					papp->StrId(),
					ApplicationStatusIF::StateStr(papp->State()),
					ApplicationStatusIF::SyncStateStr(papp->SyncState()));
			return true;
		}

		// Avoid double AWM selection for RUNNING applications with already
		// assigned AWM.
		if ((papp->State() == Application::RUNNING) && papp->NextAWM()) {
			logger->Debug("Skipping [%s] AWM %d => No reconfiguration",
					papp->StrId(), papp->CurrentAWM()->Id());
			return true;
		}

		// Avoid double AWM selection for SYNCH applications with an already
		// assigned AWM.
		if ((papp->State() == Application::SYNC) && papp->NextAWM()) {
			logger->Debug("Skipping [%s] AWM already assigned [%d]",
					papp->StrId(), papp->NextAWM()->Id());
			return true;
		}

		return false;
	}

	/**
	 * @brief Compare scheduling entities
	 *
	 * The function is used to order the list of scheduling entities
	 */
	static bool CompareEntities(SchedEntityPtr_t & se1,
			SchedEntityPtr_t & se2);

};

} // namespace plugins

} // namespace bbque

#endif // BBQUE_YAMS_SCHEDPOL_H_

