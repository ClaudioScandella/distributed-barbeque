#!/bin/bash

OUT=${1:-"."}
PLOTTER="@CMAKE_INSTALL_PREFIX@/bin/feedgnuplot"

GPLINE_SIG="set style line 1 lt 2 lc rgb \"#251BE0\" lw 1 ps 1"
GPLINE_AVG="set style line 2 lt 2 lc rgb \"#E0A51B\" lw 2"
GPLINE_FIL="set style line 3 lt 2 lc rgb \"#E3070A\" lw 2"
GPLINE_TRD="set style line 4 lt 2 lc rgb \"#0C6E20\" lw 2"
GPLINE_SIG_PS="set style line 1 lt 2 lc rgb \"#251BE0\" lw 1 ps 1"
GPLINE_AVG_PS="set style line 2 lt 2 lc rgb \"#E0A51B\" lw 2"
GPLINE_FIL_PS="set style line 3 lt 2 lc rgb \"#E3070A\" lw 2"
GPLINE_TRD_PS="set style line 4 lt 2 lc rgb \"#0C6E20\" lw 2"

GPOPTS_X11="\
set terminal x11 1 \
title \"Signal Plot Analysis\" \
enhanced font \"arial,6\" \
noraise; \
set key horizontal; \
set key left top; \
$GPLINE_SIG; \
$GPLINE_AVG; \
$GPLINE_FIL; \
$GPLINE_TRD; \
"

GPOPTS_PNG="\
set terminal png \
nocrop enhanced \
font verdana 10 \
size 950,230; \
set key horizontal; \
set key left top; \
$GPLINE_SIG_PS; \
$GPLINE_AVG_PS; \
$GPLINE_FIL_PS; \
$GPLINE_TRD_PS; \
"

GPOPTS_EPS="\
set terminal postscript eps \
enhanced color \
\"Times-Roman\" 10 \
size 8,2; \
set key horizontal; \
set key left top; \
$GPLINE_SIG_PS; \
$GPLINE_AVG_PS; \
$GPLINE_FIL_PS; \
$GPLINE_TRD_PS; \
"

################################################################################
# Terminal Coloring Suppport
################################################################################

DULL=0
BRIGHT=1

FG_BLACK=30
FG_RED=31
FG_GREEN=32
FG_YELLOW=33
FG_BLUE=34
FG_VIOLET=35
FG_CYAN=36
FG_WHITE=37

FG_NULL=00

BG_BLACK=40
BG_RED=41
BG_GREEN=42
BG_YELLOW=43
BG_BLUE=44
BG_VIOLET=45
BG_CYAN=46
BG_WHITE=47

BG_NULL=00

##
# ANSI Escape Commands
##
ESC="\033"
NORMAL="\E[m\]"
RESET="\E[${DULL};${FG_WHITE};${BG_NULL}m"

##
# Shortcuts for Colored Text ( Bright and FG Only )
##

# DULL TEXT
BLACK="\E[${DULL};${FG_BLACK}m"
RED="\E[${DULL};${FG_RED}m"
GREEN="\E[${DULL};${FG_GREEN}m"
YELLOW="\E[${DULL};${FG_YELLOW}m"
BLUE="\E[${DULL};${FG_BLUE}m"
VIOLET="\E[${DULL};${FG_VIOLET}m"
CYAN="\E[${DULL};${FG_CYAN}m"
WHITE="\E[${DULL};${FG_WHITE}m"

# BRIGHT TEXT
BRIGHT_BLACK="\E[${BRIGHT};${FG_BLACK}m"
BRIGHT_RED="\E[${BRIGHT};${FG_RED}m"
BRIGHT_GREEN="\E[${BRIGHT};${FG_GREEN}m"
BRIGHT_YELLOW="\E[${BRIGHT};${FG_YELLOW}m"
BRIGHT_BLUE="\E[${BRIGHT};${FG_BLUE}m"
BRIGHT_VIOLET="\E[${BRIGHT};${FG_VIOLET}m"
BRIGHT_CYAN="\E[${BRIGHT};${FG_CYAN}m"
BRIGHT_WHITE="\E[${BRIGHT};${FG_WHITE}m"

################################################################################
# A set of utility functions
################################################################################

# Get a new random number
random() {
od -A n -t d -N 2 /dev/urandom
}

# Generate a vector of random numbers
# $1 - the count of random numbers to return
# return: set the RND vector
getRandoms() {
RND=(`od -A n -t d2 -N $(($1*2)) /dev/urandom`)
#echo "Get randoms: ${RND[@]}"
}

# Compute an RPN expression
rpn() {
echo "3k $1 p" | dc
}

calc() {
echo "scale=3; $1" | bc
}

round() {
echo "scale=0; $1 / 1" | bc
}


echoerr() {
echo -e "$@" 1>&2
}

START=$(echo | ts %.s)
getTime() {
NOW=$(echo | ts %.s)
calc "$NOW - $START"
}

################################################################################
# Calculator process
################################################################################

BC_FIFO_IN_NAME=bbqueSignalAlalyzer_bc_in
BC_FIFO_IN=$(mktemp -u /tmp/${BC_FIFO_IN_NAME}_XXXXXX)
mkfifo $BC_FIFO_IN  2>/dev/null
BC_FIFO_OUT_NAME=bbqueSignalAlalyzer_bc_out
BC_FIFO_OUT=$(mktemp -u /tmp/${BC_FIFO_OUT_NAME}_XXXXXX)
mkfifo $BC_FIFO_OUT 2>/dev/null

# Start a BC computation server (BCS)
runCalculator() {
# Keep output pipe open, without reading it...
$(while sleep 7d; do :; done < $BC_FIFO_OUT) &
# Open input pipe and attach it to BC... with put results in output pipe
$(stdbuf -oL tail -f $BC_FIFO_IN | bc > $BC_FIFO_OUT) &
}

# Run the specified computation using the BC server (BCS)
# $1 - the BC code to execute
# return: set the RESULTS array
bcsComputation() {
#echo -e "BC Code:\n$1"
echo -e "scale=3; $1" > $BC_FIFO_IN
RESULTS=(`read R < $BC_FIFO_OUT; echo $R`)
#echo -e "Results:\n${RESULTS[@]}"
}

# Run the specified computation using the BC server (BCS)
# $1 - the BC code to execute
# return: a single value
bcsCalc() {
#echo -e "BC Code:\nscale=3; $1"
echo -e "scale=3; $1 print res, \"\\\n\";" > $BC_FIFO_IN
read RESULT < $BC_FIFO_OUT
echo $RESULT
}

################################################################################
# Distribution Generators
################################################################################

# Generate a uniform distributed number with defined
# $1 - minimum
# $2 - maximum
uniform() {
RN=$(random)
bcsCalc "res = ((($2 - $1) * $RN / 65536) + $1);"
}

# Test the uniform distribution with the specified:
# $1 - min
# $2 - max
# $3 - number of samples
testUniform() {
unset samples
LOWER_BOUND=$(calc "")
for i in `seq 1 $3`; do
	SAMPLE=$(uniform $1 $2)
	INDEX=$(round "1000 * $SAMPLE")
	let samples[$INDEX]++
done
for o in ${!samples[*]}; do
	SAMPLE=$(calc "$o / 1000")
	printf "%.3f %5d\n" $SAMPLE ${samples[o]}
done
}

testUniformPlot() {
testUniform $1 $2 $3 | $PLOTTER \
	--nolines --points \
	--domain --nodataid \
	--xlabel "Samples" \
	--ylabel "Occurrences" \
	--title "Uniform Distribution Samples"
}

# Get a normally distributed number with defined
# $1 - mean
# $2 - stddev
# Ref: http://www.protonfish.com/random.shtml
normal() {
# Generate the 3 random we need for the model
getRandoms 3
CODE="\
u1 = (2 * ${RND[0]} / 65536) -1; \
u2 = (2 * ${RND[1]} / 65536) -1; \
u3 = (2 * ${RND[2]} / 65536) -1; \
n11 = 3 + ((u1*2) - 1) + ((u2*2) - 1) + ((u3*2) - 1); \
res = ($1 + (n11 * $2)); \
"
bcsCalc "$CODE"
}

# Test the normal distribution with the specified:
# $1 - mean
# $2 - stddev
# $3 - number of samples
testNormal() {
unset samples
LOWER_BOUND=$(calc "")
for i in `seq 1 $3`; do
	SAMPLE=$(normal $1 $2)
	INDEX=$(round "1000 * $SAMPLE")
	let samples[$INDEX]++
done
for o in ${!samples[*]}; do
	SAMPLE=$(calc "$o / 1000")
	stdbuf -oL printf "%.3f %5d\n" $SAMPLE ${samples[o]}
done
}

testNormalPlot() {
testNormal $1 $2 $3 | $PLOTTER \
	--nolines --points \
	--domain --nodataid \
	--stream \
	--xlabel "Samples" \
	--ylabel "Occurrences" \
	--title "Normal Distribution Samples"
}

################################################################################
# Exp Moving Average
################################################################################
emaInit() {
SAMPLES=$1
bcsCalc "res = (2.0 / ($SAMPLES + 1));"
}

emaUpdate() {
ALPHA=$1
EMA=$2
NEW=$3
bcsCalc "res = (($ALPHA * $NEW) + ((1 - $ALPHA) * $EMA));"
}

################################################################################
# GG Filter
################################################################################
# This filter is defined by 3 parameters:
#
#        ^
#        |
#   GG2  |.........../
#        |          /.
#        |         / .
#        |        /  .
#        |       /   .
#        |      /    .
#   GG1  |------     .
#        |     .     .
#        |     .     .
#        |     .     .
#        +-------------------->
#
#             RR1  2*RR1

ggFilterAlpha() {
bcsCalc  "res = (($S_GG_TRD_GG2 - $S_GG_TRD_GG1) / ($S_GG_TRD_RR1));"
}

ggFilterBeta() {
bcsCalc "res = ((2 * $S_GG_TRD_GG1) - $S_GG_TRD_GG2);"
}
# Compute the GG value for the specified RR value:
# $1 - The RR of interest
ggFilterGGThreshold() {
bcsCalc "if ($1 < $S_GG_TRD_RR1) res = $S_GG_TRD_GG1 else res = (($S_GG_TRD_ALPHA * $1) + $S_GG_TRD_BETA);"
}

################################################################################
# Simulation Model Configuration, Status and Metrics
################################################################################

# Model and Plots Configuration
C_STEP_TIME=1     # Time of a single simulation step [s]
C_PLOT_ALL=0       # Signal to Plot: 1: all, 0: only enabled filters
C_PLOT_AWM_YMAX=6
C_PLOT_GGV_YMAX=120
C_PLOT_GGF_YMAX=20
C_PLOT_RRF_YMAX=100

# Model Status
S_CPS=10           # Cycles Per Second [Hz]
S_CPS_TIME=0       # Cycle Period [s]
S_RND_GG_MIN=0     # GG Random Generator Mimimum
S_RND_GG_MAX=0     # GG Random Generator Maximum
S_RND_GG_DLT=0     # GG Random Generator Delta, i.e. Min-Max
S_GG_EMA_SMPLS=60  # GG EMA Samples number
S_GG_EMA_ALPHA=0   # GG EMA Alpha value
S_GG_TRD_RR1=4     # GG Filter: RR1 value [%]
S_GG_TRD_GG1=5     # GG Filter: GG1 value
S_GG_TRD_GG2=80    # GG Filter: GG2 value
S_GG_TRD_ALPHA=0   # GG Filter: Alpha value
S_GG_TRD_BETA=0    # GG Filter: Beta value
S_GV_EMA_SMPLS=60  # GV EMA Samples number
S_GV_EMA_ALPHA=0   # GV EMA Alpha value
S_RC_RUN_TIME=20   # The [ms] AVERAGE for onRun
S_RC_RUN_STDV=2    # The [ms] STDDEV  for onRun
S_RC_MON_TIME=0.5  # The [ms] AVERAGE for onMonitor
S_RC_MON_STDV=0.1  # The [ms] STDDEV  for onMonitor
S_RC_RCF_TIME=300  # The [ms] AVERAGE for onConfigure
S_RC_RCF_STDV=50   # The [ms] STDDEV  for onConfigure
S_RR_EMA_SMPLS=60  # RR EMA Samples number
S_RR_EMA_ALPHA=0   # RR EMA Alpha value
S_CTME=0     # Current Cycle Time
S_NTME=0     # Next Cycle Time
S_RTME=0     # Last Reconfiguration request Time
S_UTME=500   # The [ms] from a switchUp reconfiguration
S_DTME=100   # The [ms] from a switchDown reconfiguration
S_PAWM=1     # Previous AWM
S_CAWM=1     # Current  AWM
S_SM_CAPP=0  # Application control: 0 stable, 1 unstable
S_SM_CGGT=0  # GG Threshold control: 0 disabled, 1 enabled
S_SM_CRRT=0  # BBQ control: 0 disabled, 1 enabled

# Model Metrics
M_RC_RTME=0  # The last onRun time
M_RC_MTME=0  # The last onMonitor time
M_RC_CTME=0  # The last onConfigure time
M_AWSTB=1    # Application Working Mode Stability Flag: >0 stable, 0: unstable
M_GGPRV=0    # GoalGap Value Previous
M_GGCUR=0    # GoalGap Value Current
M_GGEMA=0    # GoalGap Value EMA
M_GGTRD=0    # GoalGap Value Threshold
M_GGSTB=1    # GoalGap Value Stability Flag: >0 stable, 0: unstable
M_GGVAR=0    # GoalGap Variation
M_GVEMA=0    # GoalGap Variation EMA
M_GVTRD=5    # GoalGap Variation Threshold
M_GGFWD=1    # GoalGap Forward Flag: >0 forwarded, 0: stopped
M_RRCUR=0    # Reconfiguration Rate Current
M_RREMA=0    # Reconfiguration Rate EMA
M_RRTRD=5    # Reconfiguration Rate Threshold [%]

# Simulation mode string representation
S_SM_APP[0]="${GREEN}Stable${RESET}"
S_SM_APP[1]="${YELLOW}Unstable${RESET}"
S_SM_CTR[0]="${RED}Disabled${RESET}"
S_SM_CTR[1]="${GREEN}Enabled${RESET}"


################################################################################
# Data Generator Configuration
################################################################################

# Report current configuration
cfgReport() {
clear
usage
echo
echo -e "Current configuration"
echo -e "Application:"
printf  "  cps............. %3d\n" $S_CPS
echo -e "  behavior........ ${S_SM_APP[$S_SM_CAPP]}"
echo -e "GoalGap:"
printf  "  min............. %3d\n" $S_RND_GG_MIN
printf  "  max............. %3d\n" $S_RND_GG_MAX
printf  "  ema_samples..... %3d\n" $S_GG_EMA_SMPLS
echo
echo -e "GoalGap Filter:"
printf  "  ema_samples..... %3d\n" $S_GV_EMA_SMPLS
echo -e "  control......... ${S_SM_CTR[$S_SM_CGGT]}"
echo
echo -e "Reconfiguration Rate Filter:"
printf  "  ema_samples..... %3d\n" $S_RR_EMA_SMPLS
printf  "  RR1 threshold... %5.1f [%%]\n" $(bcsCalc "res = (100 * $S_GG_TRD_RR1);")
printf  "  GG1 threshold... %3d   (@ 1xRR1)\n" $S_GG_TRD_GG1
printf  "  GG2 threshold... %3d   (@ 2xRR1)\n" $S_GG_TRD_GG2
echo -e "  control......... ${S_SM_CTR[$S_SM_CRRT]}"
echo
}

# Configure the random numbers generator
cfgUpdate() {
case $1 in

"cps") # CPS Configuration
S_CPS=$2
S_CPS_TIME=$(calc "1 / $2")
;;

"gg") # Goal Gap Configuration
S_RND_GG_MIN=$2
S_RND_GG_MAX=$3
S_RND_GG_DLT=$(calc "$3 - $2")
S_GG_EMA_SMPLS=$4
S_GG_EMA_ALPHA=$(emaInit  $4)
;;

"gv") # Goal Gap Variation Configuration
S_GV_EMA_SMPLS=$2
S_GV_EMA_ALPHA=$(emaInit  $2)
;;

"rr") # Reconfiguration Rate Configuration
S_RR_EMA_SMPLS=$2
S_RR_EMA_ALPHA=$(emaInit  $S_RR_EMA_SMPLS)
S_GG_TRD_RR1=$3
S_GG_TRD_GG1=$4
S_GG_TRD_GG2=$5
S_GG_TRD_ALPHA=$(ggFilterAlpha)
S_GG_TRD_BETA=$(ggFilterBeta)
;;

"mode") # Simulation Mode
S_SM_CAPP=$2
S_SM_CGGT=$3
S_SM_CRRT=$4
;;

esac

# Dump current configuration
cfgReport

}

CFGFIFO=$(mktemp -u /tmp/bbqueSignalAlalyzer_rndcfg_XXXXXX)
mkfifo $CFGFIFO

################################################################################
# Custom Samplers for GoalGap Variance
################################################################################

# Compute GG variation
# return: (CurrentGG, VariationGG)
ggVarGenerator() {
[ -n "$1" ] && VAL=$1 || VAL=$(random)
[ -n "$1" ] && RND=0  || RND=1
CODE="\
if ($RND == 1) {						\n\
  m_ggcur = ($S_RND_GG_MIN + (($S_RND_GG_DLT * $VAL) / 65536))	\n\
} else {							\n\
  m_ggcur = $VAL						\n\
}								\n\
m_ggvar = (m_ggcur - $M_GGPRV);					\n\
if (m_ggvar < 0) {						\n\
  m_ggvar = -m_ggvar						\n\
};								\n\
print m_ggcur, \" \", m_ggvar, \"\\\n\"				\n\
"
bcsComputation "$CODE"
M_GGCUR=${RESULTS[0]}
M_GGVAR=${RESULTS[1]}
M_GGPRV=$M_GGCUR
}

################################################################################
# Control Model
################################################################################


# Check the stability of the Application Working mode
# return: 1 stable, 0: unstable
checkAWStability() {
# Consider AW always stable if RTLib control is disabled
[ $S_SM_CGGT -eq 0 ] && return 1
# AW stability condition:
M_AWSTB=$(bcsCalc "if ($M_RREMA < $M_RRTRD) res = $C_PLOT_AWM_YMAX else res = 0;")
return $M_AWSTB
}

# Check the stability of the GG metrics
# return: >0 stable, 0: unstable
checkGGStability() {
# Consider GG always stable if GG control is disabled
[ $S_SM_CGGT -eq 0 ] && return 1
# GG stability condition:
M_GGSTB=$(bcsCalc "if ($M_GVEMA < $M_GVTRD) res = $C_PLOT_GGV_YMAX else res = 0;")
return $M_GGSTB
}

# Check the ability to issue GG
# return: >0 enabled, 0: disabled
checkGGForwarding() {
# Consider GG always enabled if RR control is disabled
[ $S_SM_CRRT -eq 0 ] && return 1
# GG enable condition:
M_GGFWD=$(bcsCalc "if ($M_GGTRD < $M_GGEMA) res = $C_PLOT_RRF_YMAX else res = 0;")
return $M_GGFWD
}


################################################################################
# AWM Assignement Model
################################################################################

# Switch the current AWM, if required
# This function simulate the BBQ policy
switchAWM() {
S_PAWM=$S_CAWM
SWITCH_TIME=$(bcsCalc "if (($S_RTME>0) && ($S_RTME<=$S_CTME)) res = 1 else res = 0;")
[ $SWITCH_TIME -eq 0 ] && return

NAWM=1
[ $S_CAWM -eq 1 ] && NAWM=3

#printf "%9.6f Switch AWM: $S_CAWM => $NAWM\n" $S_CTME
S_CAWM=$NAWM
S_RTME=0
}

# Update the GoalGap metrics
updateGG() {
if [ $S_CAWM -eq 1 ]; then
	# AWM Low => compute GG
	ggVarGenerator
else
	# AWM High => GG = 0;
	ggVarGenerator 0
fi
M_GGEMA=$(emaUpdate $S_GG_EMA_ALPHA $M_GGEMA $M_GGCUR)
M_GGTRD=$(ggFilterGGThreshold $M_RREMA)
M_GVEMA=$(emaUpdate $S_GV_EMA_ALPHA $M_GVEMA $M_GGVAR)
}

# Update the time for an AWM reconfiguration
setReconfigurationTime() {

# Setup just one reconf per time
REC=$(bcsCalc "if ($S_RTME > 0) res = 0 else res = 1;")
[ $REC -eq 0 ] && return

# Avoid reconfs if GG is not stable
checkGGStability && return

# If we are in the Lower AWM...
if [ $S_CAWM -eq 1 ]; then
	# Avoid reconfs if GG forwarding is not enabled
	checkGGForwarding && return
fi

DTIME=$S_UTME
[ $S_CAWM -eq 3 ] && DTIME=$S_DTME

PTME=$(bcsCalc "res = (($M_RC_RTME + $M_RC_MTME + $M_RC_CTME) / 1000);")
S_RTME=$(bcsCalc "res = ($S_CTME + $PTME + ($DTIME / 1000));")
#printf "%9.6f Reconfigure scheduled @ $S_RTME\n" $S_CTME
}

# Update the Reconfiguration Rate metrics
updateRR() {
# Generate the 3x3 random we need for the model
getRandoms 9
# Setup RR computation code
CODE="\
# Get 3 triplets of Uniform distributed [-1;1] numbers				\n\
u11 = (2 * ${RND[0]} / 65536) + 1; 						\n\
u12 = (2 * ${RND[1]} / 65536) + 1; 						\n\
u13 = (2 * ${RND[2]} / 65536) + 1; 						\n\
u21 = (2 * ${RND[3]} / 65536) + 1; 						\n\
u22 = (2 * ${RND[4]} / 65536) + 1; 						\n\
u23 = (2 * ${RND[5]} / 65536) + 1; 						\n\
u31 = (2 * ${RND[6]} / 65536) + 1; 						\n\
u32 = (2 * ${RND[7]} / 65536) + 1; 						\n\
u33 = (2 * ${RND[8]} / 65536) + 1; 						\n\
# Get 3 normal distrbuted numbers						\n\
n11 = 3 + ((u11 * 2) - 1) + ((u12 * 2) - 1) + ((u13 * 2) - 1); 			\n\
n12 = 3 + ((u21 * 2) - 1) + ((u22 * 2) - 1) + ((u23 * 2) - 1); 			\n\
n13 = 3 + ((u31 * 2) - 1) + ((u32 * 2) - 1) + ((u33 * 2) - 1); 			\n\
# Compute onRun, onMonitor and onConfigure time with Normal Distribution	\n\
m_rc_rtme = $S_RC_RUN_TIME + (n11 * $S_RC_RUN_STDV); 				\n\
m_rc_mtme = $S_RC_MON_TIME + (n12 * $S_RC_MON_STDV); 				\n\
m_rc_ctme = 0; 									\n\
if ($S_PAWM != $S_CAWM) 							\n\
  m_rc_ctme = $S_RC_RCF_TIME + (n13 * $S_RC_RCF_STDV); 				\n\
# Compute current RR and update its EMA value					\n\
m_rrcur = (m_rc_mtme + m_rc_ctme) / (m_rc_rtme); 				\n\
m_rrema = m_rrcur; 								\n\
if (m_rrcur <= $M_RREMA) 							\n\
  m_rrema = ($S_RR_EMA_ALPHA * m_rrcur) + ((1 - $S_RR_EMA_ALPHA) * $M_RREMA);	\n\
# Compute next simulation 15:49							\n\
step_time_s = (m_rc_rtme + m_rc_mtme + m_rc_ctme) / 1000; 			\n\
if (step_time_s < $S_CPS_TIME) {						\n\
  s_ntme = ($S_CTME + $S_CPS_TIME) 						\n\
} else {									\n\
  s_ntme = ($S_CTME + step_time_s)						\n\
};										\n\
print m_rc_rtme, \" \", m_rc_mtme, \" \", m_rc_ctme, \" \", m_rrcur, \" \", m_rrema, \" \", s_ntme, \"\n\" \
"
# Run code on BCS
bcsComputation "$CODE"
M_RC_RTME=${RESULTS[0]};
M_RC_MTME=${RESULTS[1]};
M_RC_CTME=${RESULTS[2]};
M_RRCUR=${RESULTS[3]};
M_RREMA=${RESULTS[4]};
S_NTME=${RESULTS[5]};
}

# Update the current AWM model, where:
simulationCycle() {

# Check if current AWM must be changed
switchAWM

# Update the GG model
updateGG

# Compute the RR metrics
updateRR

# Compute the AW stability flag
checkAWStability

#  set time of next reconfiguration
[ $S_SM_CAPP -eq 1 ] && setReconfigurationTime

}

setupPlotValue() {
P_GGTRD=$M_GGTRD
P_GGCUR=$M_GGCUR
P_GGEMA=$M_GGEMA
P_GGSTB=$M_GGSTB
P_GGFWD=$M_GGFWD
P_GGVAR=$M_GGVAR
P_GVTRD=$M_GVTRD
P_GVEMA=$M_GVEMA
P_RRTRD=$M_RRTRD
P_RRCUR=$M_RRCUR
P_RREMA=$M_RREMA

[ $C_PLOT_ALL -eq 1 ] && return

# Forcely reset GG plots on GG filter disabled
[ $S_SM_CGGT -eq 0 ] \
	&& P_GVTRD=0

# Forcely reset RR plots on RR filter disabled
[ $S_SM_CRRT -eq 0 ] \
	&& P_RRTRD=0 \
	&& P_RREMA=0 \
	&& P_GGTRD=0

}

################################################################################
# A Samples Generator
################################################################################

PLOT_AWM_NAME=bbqueSignalAlalyzer_plotAWM
PLOT_AWM=$(mktemp -u /tmp/${PLOT_AWM_NAME}_XXXXXX)
mkfifo $PLOT_AWM
PLOT_GG_NAME=bbqueSignalAlalyzer_plotGG
PLOT_GG=$(mktemp -u /tmp/${PLOT_GG_NAME}_XXXXXX)
mkfifo $PLOT_GG
PLOT_GV_NAME=bbqueSignalAlalyzer_plotGGFilter
PLOT_GV=$(mktemp -u /tmp/${PLOT_GV_NAME}_XXXXXX)
mkfifo $PLOT_GV
PLOT_RR_NAME=bbqueSignalAlalyzer_plotRRFilter
PLOT_RR=$(mktemp -u /tmp/${PLOT_RR_NAME}_XXXXXX)
mkfifo $PLOT_RR

# Clean-up previously generated .dat files
rm -f ${OUT}/bbqueSignalAlalyzer_plot*.dat

# A simulation step correspond to the simulation of all events happening
# in a timeframe of abount 1[s]
simulationStep() {
STME=$(bcsCalc "res = ($S_CTME + $C_STEP_TIME);")
RUN=1
while [ $RUN -eq 1 ]; do

    # Get current time
    S_CTME=$S_NTME

    # Do a new simulation cycle
    simulationCycle

    # Setup the values to plot based on filters enabled
    setupPlotValue

    # Dump metrics
    printf "%9.6f Value %2d Stability %3d\n" \
		$S_CTME $S_CAWM $M_AWSTB| \
	    stdbuf -oL tee -a ${OUT}/${PLOT_AWM_NAME}.dat \
	    >$PLOT_AWM
    printf "%9.6f Threshold %7.3f Value %7.3f EMA %7.3f Stability %3d\n" \
		$S_CTME $P_GGTRD $P_GGCUR $P_GGEMA $P_GGSTB | \
	    stdbuf -oL tee -a ${OUT}/${PLOT_GG_NAME}.dat \
	    >$PLOT_GG
    printf "%9.6f Threshold %7.3f Value %7.3f EMA %7.3f\n" \
		$S_CTME $P_GVTRD $P_GGVAR $P_GVEMA | \
	    stdbuf -oL tee -a ${OUT}/${PLOT_GV_NAME}.dat \
	    >$PLOT_GV
    printf "%9.6f Threshold %7.3f Value %7.3f EMA %7.3f Forwarding %3d\n" \
		$S_CTME $P_RRTRD $P_RRCUR $P_RREMA $P_GGFWD | \
	    stdbuf -oL tee -a ${OUT}/${PLOT_RR_NAME}.dat \
	    >$PLOT_RR

    # Check simulation step completion
    RUN=$(bcsCalc "res=0; if ($S_CTME < $STME) res=1;")

done
}


# The data generator
dataSource() {
while true; do
	# Do a simulation step
	T1=$(getTime)
	simulationStep
	T2=$(getTime)

	SLEEP_TIME=$(bcsCalc "res = ($C_STEP_TIME - ($T2 - $T1)); if (res <= 0) res = .001;")

	# Wait for next sample, or update the configuration
	read -t $SLEEP_TIME <>$CFGFIFO SETTINGS && cfgUpdate $SETTINGS
done
}

# A configurable plotting function, where:
# $1 - data source
# $2 - Title
# $3 - Y axis label
# $4 - Y min (or - for 0)
# $5 - Y max (or - for autoscale)
# $6 - extra plot options (or - for none)
# $7 - Geometry
plotData() {
YMIN="--ymin=0"
YMAX=""
OPTS=""
[  $4  != "-" ] && YMIN="--ymin=$4"
[  $5  != "-" ] && YMAX="--ymax=$5"
[ "$6" != "-" ] && OPTS="$6"
tail -n0 -f "$1" | $PLOTTER \
	--autolegend \
	--lines \
	--domain --dataid \
	--xlabel "Time [s]" \
	--ylabel "$3" \
	  $YMIN  $YMAX \
	--title  "$2" \
	--stream --xlen 90 \
	--extracmd "$GPOPTS_X11 $OPTS" \
	--curvestyle Value "with point ls 1" \
	--curvestyle EMA "ls 2" \
	--curvestyle Threshold "ls 3" \
	--curvestyle Stability "with point ls 2" \
	--curvestyle Forwarding "with point ls 2" \
	--geometry "$7" &
}

cat >bbqueStabilityAnalysisPrinter.sh <<EOF
#!/bin/bash
# \$1: Image Format (png|eps)
# \$2: Start plto time (or 0 for none)
# \$3: End plot time (or 0 for none)
FMT=\${1:-"png"}
START=\${2:--1}
END=\${3:--1}

GPOPTS_PNG='$GPOPTS_PNG'
GPOPTS_EPS='$GPOPTS_EPS'

GPOPTS=\$GPOPTS_PNG
[ \$FMT == "eps" ] && GPOPTS=\$GPOPTS_EPS

# Plot previously collected data, where:
# \$1 - data source
# \$2 - Title
# \$4 - Y min (or - for 0)
# \$5 - Y max (or - for autoscale)
# \$6 - extra plot options (or - for none)
# \$7 - the output filename (without extension)
printData() {
YMIN="--ymin=0"
YMAX=""
OPTS=""
[  \$4  != "-" ] && YMIN="--ymin=\$4"
[  \$5  != "-" ] && YMAX="--ymax=\$5"
[ "\$6" != "-" ] && OPTS="\$6"
cat "\$1" | \
	awk "{if(\\\$1<\$START || (\$END>0 && \\\$1>\$END)) next; else print \\\$0}" | \
	$PLOTTER \
	--autolegend \
	--lines \
	--domain --dataid \
	--xlabel "Time [s]" \
	--ylabel "\$3" \
	  \$YMIN  \$YMAX \
	--title  "\$2" \
	--extracmd "\$GPOPTS \$OPTS" \
	--curvestyle Value "with point ls 1" \
	--curvestyle EMA "ls 2" \
	--curvestyle Threshold "ls 3" \
	--curvestyle Stability "with point ls 2" \
	--curvestyle Forwarding "with point ls 2" \
	--hardcopy "\$7".\$FMT
}

[ \$START -ne -1 ] && TIMEFRAME="_\${START}"
[ \$START -ne -1 ] && [ \$END -ne -1 ] && TIMEFRAME="\${TIMEFRAME}-\$END"

EOF
chmod a+x bbqueStabilityAnalysisPrinter.sh

################################################################################
# Command line processing
################################################################################

tuneGenerator() {
case $1 in

"cps") # CPS Configuration
[ $2 != '-' ] && S_CPS=$2
echo "$1 $S_CPS" >$CFGFIFO
;;

"gg") # Goal Gap Configuration
[ $2 != '-' ] && [ $2 -lt $S_RND_GG_MAX -o $2 -lt $3 ] && S_RND_GG_MIN=$2
[ $3 != '-' ] && [ $3 -gt $S_RND_GG_MIN -o $3 -gt $2 ] && S_RND_GG_MAX=$3
[ $3 == 0 ] && S_RND_GG_MIN=0 && S_RND_GG_MAX=0
[ $4 != '-' ] && S_GG_EMA_SMPLS=$4
echo "$1 $S_RND_GG_MIN $S_RND_GG_MAX $S_GG_EMA_SMPLS" >$CFGFIFO
;;

"gv") # Goal Gap Variation Configuration
[ $2 != '-' ] && S_GV_EMA_SMPLS=$2
echo "$1 $S_GV_EMA_SMPLS" >$CFGFIFO
;;

"rr") # Reconfiguration Rate Configuration
[ $2 != '-' ] && S_RR_EMA_SMPLS=$2
[ $3 != '-' ] && S_GG_TRD_RR1=$(bcsCalc "res = ($3 / 100);")
[ $4 != '-' ] && S_GG_TRD_GG1=$4
[ $5 != '-' ] && S_GG_TRD_GG2=$5
echo "$1 $S_RR_EMA_SMPLS $S_GG_TRD_RR1 $S_GG_TRD_GG1 $S_GG_TRD_GG2" >$CFGFIFO
;;

"mode") # Model Mode
[ $2 != '-' ] && S_SM_CAPP=$2
[ $3 != '-' ] && S_SM_CGGT=$3
[ $4 != '-' ] && S_SM_CRRT=$4
echo "$1 $S_SM_CAPP $S_SM_CGGT $S_SM_CRRT" >$CFGFIFO
;;

*) # Unsopported command
echo "Unsupported command: $1"
;;

esac

}


################################################################################
# Main plotting function
################################################################################

usage() {
echo -e "${LGRAY}\n\n"
echo "***** Signal Test Analyzer *****"
echo
echo "Tuning commands:"
echo " cps <cps>"
echo "    tune the application behaviors, where:"
echo "    cps  - set the number of samples per seconds (CPS)"
echo " gg <min> <max> <ema>"
echo "    tune the application generated GoalGap values, where:"
echo "    min  - set the minimum value for the GG random generator"
echo "    max  - set the maximum value for the GG random generator"
echo "    ema  - set the number of samples for the GG Exponential Moving Average (EMA)"
echo " gv <ema>"
echo "    tune the GoalGap Variation Filter, where:"
echo "    ema  - set the number of samples for the GV Exponential Moving Average (EMA)"
echo " rr <ema> <rr1> <gg1> <gg2>"
echo "    tune the Reconfiguration Rate (RR) Filter, where:"
echo "    ema  - set the number of samples for the RR Exponential Moving Average (EMA)"
echo "    rr1  - set the RR upper-bound for the constant RR threshold"
echo "    gg1  - set the constant GG threshold"
echo "    gg2  - set the linear GG threshold at 2*RR1"
echo "    "
echo " mode <app> <ggc> <rrc>"
echo "    tune the system behaviors and control mechanisms, where:"
echo "    app  - Application behaviors              0: stable,   1: unstable"
echo "    ggc  - GoalGap control mode               0: disabled, 1: enabled"
echo "    rrc  - Reconfiguration Rate control mode  0: disabled, 1: enabled"
echo
echo "Use '-' to keep the previous value"
echo
}

plot() {
# Tuning command memento and current configuration dump
cfgReport
# Start data plotters
plotData $PLOT_AWM 'Application Working Mode (AWM) Metrics' '' 0 $C_PLOT_AWM_YMAX '' 949x233+-5+-8
plotData $PLOT_GG 'Goal Gap (GG) Metrics' '' 0 $C_PLOT_GGV_YMAX '' 949x233+-5+255
plotData $PLOT_GV 'Goal Gap (GG) Filter' '' 0 $C_PLOT_GGF_YMAX '' 949x233+-5+517
plotData $PLOT_RR 'Reconfiguration Rate (RR) Filter (log)' '' 0.01 $C_PLOT_RRF_YMAX 'set logscale y;' 949x233+-5-25
# Start data generator
dataSource &
}

cat >>bbqueStabilityAnalysisPrinter.sh <<EOF
printData ${OUT}/${PLOT_AWM_NAME}.dat \
	'Application Working Mode (AWM) Metrics' \
	'' \
	0 $C_PLOT_AWM_YMAX \
	'' \
	${OUT}/${PLOT_AWM_NAME}\${TIMEFRAME}
printData ${OUT}/${PLOT_GG_NAME}.dat \
	'Goal Gap (GG) Metrics' \
	'' \
	0 $C_PLOT_GGV_YMAX \
	'' \
	${OUT}/${PLOT_GG_NAME}\${TIMEFRAME}
printData ${OUT}/${PLOT_GV_NAME}.dat \
	'Goal Gap (GG) Filter' \
	'' \
	0 $C_PLOT_GGF_YMAX \
	'' \
	${OUT}/${PLOT_GV_NAME}\${TIMEFRAME}
printData ${OUT}/${PLOT_RR_NAME}.dat \
	'Reconfiguration Rate (RR) Filter' \
	'' \
	0.01 $C_PLOT_RRF_YMAX \
	'set logscale y;' \
	${OUT}/${PLOT_RR_NAME}\${TIMEFRAME}
EOF

################################################################################
# Return on script sourcing or Ctrl+C
################################################################################

# Return if the script has been sources
[[ $_ != $0 ]] && return 2>/dev/null

# Return on Ctrl-+ by cleaning-up all background threads
cleanup() {
	kill $(jobs -p)
	killall feedgnuplot
	rm $CFGFIFO $PLOT_GG $PLOT_GV $PLOT_RR
	rm $PLOT_AWM $PLOT_GG $PLOT_GV $PLOT_RR
	rm $BC_FIFO_IN $BC_FIFO_OUT
	cfgReport
}
trap cleanup EXIT


################################################################################
# Initialization
################################################################################

# Start the calculator process
runCalculator

# Model initialization
S_CPS_TIME=$(bcsCalc "res = (1 / $S_CPS);")
S_GG_EMA_ALPHA=$(emaInit  $S_GG_EMA_SMPLS)
S_GG_TRD_RR1=$(bcsCalc "res = ($S_GG_TRD_RR1 / 100);")
S_GG_TRD_ALPHA=$(ggFilterAlpha)
S_GG_TRD_BETA=$(ggFilterBeta)
S_GV_EMA_ALPHA=$(emaInit  $S_GV_EMA_SMPLS)
S_RR_EMA_ALPHA=$(emaInit  $S_RR_EMA_SMPLS)
M_AWSTB=$C_PLOT_AWM_YMAX
M_GGTRD=$(ggFilterGGThreshold $M_RREMA)
M_GGSTB=$C_PLOT_GGV_YMAX
M_GGFWD=$C_PLOT_RRF_YMAX
M_RRTRD=$(bcsCalc "res = ($M_RRTRD / 100);")

# Main function
plot

# This is required to properly capture the trap previously defined
while [ 1 ]; do
	read -p "$> " CMD
	[ "x$CMD" != "x" ] && tuneGenerator $CMD
	sleep .2
done
