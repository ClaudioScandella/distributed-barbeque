/*
 * Copyright (C) 2012  Politecnico di Milano
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**

@defgroup rtlib_sec02_aem RTLib Abstract Execution Model (AEM) API
@ingroup rtlib

This high-level API has been desinged to support and simplify the integration
of <b>stream processing applications</b>. These applications are characterized by a
a well defined execution workflow, which basically consists of an
initialization followed by a processing loop. The initialization setups all the
handlers and data structures required for the actual stream processing. The
processing loop, as its name imply, it's a loop where at each iteration a bunch
of data are processed.

For example, considering a video decoding application, at initialization time
the compressed video bitstream is opened and then each single frame is decoded,
one after the other, by a processing loop. Thus, in pseudocode, the classical
structure of a stream processing application could be mapped on such a
template:

\code
1 // Initialization
2 setup();
3 // Processing loop
4 while (!done) {
5 	// Compute one bunch of data (e.g. a video frame)
6 	compute();
7 }
\endcode

The BarbequeRTRM framework is targeted to manage <i>run-time tunable</i> stream
processing application. This means that:
<ul><li>
the application could have many different possible run-time configuration
profiles;
</li><li>
during the processing loop the application could switch from one
configuration to another.
</li></ul>

These <b>run-time adaptation</b> capabilities of an application are supported
by the RTLib and specifically the AEM API provides a proper set of call-back
methods which allows an easy integration of the reconfiguration code.
Reconfigurations could be triggered by:
<ul><li>
the application itself, by monitoring its run-time behaviors and tuning
application specific parameters, according to an <i>application-specific
optimization policy</i> in order to improve its performances;
</li><li>
the BarbequeRTRM, which is continuously supervising resources availability and
application requirements in order to find the best resources allocation
according to a <i>system-wide optimization policy</i>.
</li></ul>

If we consider reconfiguration capabilities, the previous pseudo-code template
could be refined to be:

\code
 1 // Initialization
 2 setup();
 3 // Processing loop
 4 while (!done) {
 5 	// Reconfiguration required
 5 	if (status() == NEED_RECONF) {
 6 		// Switch run-time profile (if needed)
 7 		configure();
 8 	}
 9 	// Compute one bunch of data (e.g. a video frame)
10 	compute();
11 	// Check performances
12 	monitor();
13 }
\endcode

which means that a run-time tunable streaming application continuously processes
its data on a specific configuration profile until a reconfiguration is
required, in that case a new profile is enabled and then the processing loop
continue.

This template defines an <b>Abstract Execution Model (AEM)</b> which could be
implemented by a <i>generic state machine</i> and specialized for a specific
stream processing application, by simply defining the operations associated to
each different state.
The AEM API provides the application developers an event-based programming
model, where events are generated by the library, according to the previously
defined execution model, and managed by a set of application defined call-back
methods.
This means that the integration of a new application requires the developer
just to implement the application specific logic into the body of few methods.

An overall view of the AEM state machine and its API is represented in the
following figure, where the set of application specific call-backs is
represented by the white parallelograms:
\image html bbque_rtlib_aem.png

This state machine is implemented by the bbque::rtlib::BbqueEXC base class,
which defines also a default implementation for all the exposed call-back
methods (white parallelograms).
A detailed description of such methods is provided in section
@ref rtlib_sec02_aem_app; in this section we just resume the overall behaviors
of the defined workflow.

In the previous image there are three main loops.
The <b>green loop</b> is the actual processing loop; an application is
continuously executing a call to bbque::rtlib::BbqueEXC::onRun()
followed by a call to bbque::rtlib::BbqueEXC::onMonitor().
The first one is where the actual processing of a bunch of data is performend,
while the second one gives the application a proper code place where the
performances of the last processing could be evaluated in order to
eventually fine tune the next cycle.

In case of a reconfiguration is required, after the monitoring call the
<b>orange path</b> is taken which corresponds to a call to
bbque::rtlib::BbqueEXC::onConfigure().
In this method the application is required to switch its current profile, so
that the processing will be continued on a new configuration.

If the execution of an application should be suspended, e.g. due
to resources being temporarely not more available, the <b>red path</b> is
entered right after the last monitoring call.
The bbque::rtlib::BbqueEXC::onSuspend method gives the application the
opportunity to save all sensible data and prepare for a resources reclaim.

When resources availability for this applications could be restored, the
processing loop will be re-entered, but not before passing through the
reconfiguration path where are called first the
bbque::rtlib::BbqueEXC::onResume and then the
bbque::rtlib::BbqueEXC::onConfigure methods.
The first one allows the application to recover its status, as it was right
previous its suspension, while the latter one configure the next to be entered
processing loop i.e. the green one in the figure) according to the new assigned
working profile.

Finally, bbque::rtlib::BbqueEXC::onRelease is called just before terminating an
application, when all its processing has been completed and the processing loop
definitively exited. The purpose of this method is quite similar but the
opposite of the bbque::rtlib::BbqueEXC::onSetup method, which instead is called
just one time at the application startup time. The onSetup call could be used
to prepare the ground for the upcoming processing to start, while the onRelease
is means to free-up everything before stopping the application.

Considering this short overall view of the AEM, it should be clear that the
main purpose of the AEM API is to relieve the application developer from the
cumbersome code required to make an application run-time tunable. This
complexity is factorized based on a generic stream processing workflow and
completely masked to the actual application by a set of well defined call-back
methods.

As a final remark, the run-time management solution proposed by the
BarbequeRTRM framework is based on the exploitation of a hierarchical control.
A system-wide run-time resource manager is in charge to partition the available
resources, among all the running application, while each application is in
charge to fine tune itself.
This application specific tuning is represented by the code which correspond to
the region in the bottom right dashed square of the previous figure. Here is
where the Quality-of-Experience (QoE) evaluation and run-time tuning take
place.
These kinds of activities are supported by another module of the RTLib,
which corresponds to an even higher abstraction level API discussed in section
@ref rtlib_sec04_rtrm.



@defgroup rtlib_sec02_aem_exc Execution Context Management
@ingroup rtlib_sec02_aem

This is a set of methods which allow to manage an <b>EXecution Context
(EXC)</b> and its interaction with the BarbequeRTRM System-Wide Run-Time
Resource Manager (SW-RTRM).

Using methods provided by this set it is possible to register new EXCs, thus
making the BarbequeRTRM aware about them, as well as to enable and disable them
at run-time. All these methods are meant to be used by the client code which
create and manage the EXCs.


@defgroup rtlib_sec02_aem_app Application Callbacks
@ingroup rtlib_sec02_aem

This is a set of methods which allow to specialize the bbque::rtlib::BbqueEXC
base class according to the specific needs of each stream processing
application that is integrated to be run-time managed by the BarbequeRTRM
framework.

A default implementation of each method is already provided by the base class,
thus an application could provide an implementation for just the ones that
really needs. Usually, at least the @c onSetup() and @c onRun() methods are
defined. While, the @c onConfigure() and @c onMonitor() are of interest for
run-time tunable applications which has at least two different Application
Working Modes (AWMs) (see @ref rtlib_sec01_recipe).

@see rtlib_sec01_recipe


@defgroup rtlib_sec02_aem_constr Constraints Management
@ingroup rtlib_sec02_aem

At run-time an application could influence its run-time tuning, as operated by
the BarbequeRTRM, by asking for an Application Working Mode (AWM) change in
case the current resoources assignement should not be considered satisfactory.
This is a set of methods which suppports these wills from applications in
either a mandatory or a best-effor approach.

The <b>madnatory</b> selection of working modes could be enforced by
enabling/disabling some of the AWMs defined by the corresponding EXC recipe.
In this case either the BarbequeRTRM is able to select a different AWM or the
application will be suspended waiting for another resources assigmenet
possibility which match the defined set of constraints.

A <b>best-effort</b> selection of working modes allows instead an application
to assert a not-mandaory request for AWM change by simply asserting the actual
error with respect to the expected performances for the current AWM.
In this case the BarbequeRTRM will do it's best to accomodate the application
request but meanwhile this last will be granted to continue its processing in
the current AWM.


@defgroup rtlib_sec02_aem_utils Utility
@ingroup rtlib_sec02_aem

This is a set of utility methods which are mostly useful to query the current
status of the stream processing application and to tune few coarse grained
behaviors, e.g. the rate of the processing cycles.
These methods could be used either by the application logic as well as from the
applications which created the EXCs.



*/
